# Creational
The primal focus of these patterns is object creation. They deal with the idea of creating specific objects for a specific use-case and then hiding the creation logic or class implementation from us. They are just exposing interfaces to us. This category of patterns can further be classified into Object-creation and Class-creation.

- Singleton
- Factory
- Abstract Factory
- Builder
- Prototype

# Structural
These patterns are concerned with the relationship between entities. They deal with the composition of a class and object, meaning that a particular object will be used in another class, making new functionalities available. Don’t forget that this relationship has something to do with Inheritance where a class inherits the members of an existing class. The two main words here are composition and inheritance.

- Adapter
- Facade
- Bridge
- Proxy
- Flyweight

# Behavioural
These patterns are most focused on communication between objects. They provide the solution for the developer to have decoupled and flexible code where they can make objects communicate with each other.

- Chain of Responsibility
- Command
- Interpreter
- Observer
- Null object

# Design Pattern Best Practices
- Design Before Code: The first practice to take before coding that project. A design before implementation gives a better edge.
- KISS — Keep It Simple Stupid: If you can’t explain it, it is not simple. The purpose of the design pattern is to make it simple and easier to understand.
- DRY — Do Not Repeat Yourself: Make your functions reusable, break them down or group them. You don’t have to rewrite the same method everywhere.
- Embrace Separation of Concern: Each service has to be separated so we know where to debug. Separate subprograms for sole responsibility.
